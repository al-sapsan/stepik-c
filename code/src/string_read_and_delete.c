#include <stdio.h>

/* Функция удаляет символ перевода строки (\n) в конце строки, если он присутствует
 * Параметры:
 *   str - указатель на строку
 *   max_len - максимальная длина буфера (для безопасности)
 */
void strip_string(char* str, int max_len) {
    int count = 0;  // Счетчик пройденных символов
    
    // Проходим по строке до конца (\0) или до достижения max_len
    // Инкрементируем указатель и счетчик на каждой итерации
    while(*str++ != '\0' && count++ < max_len);
    
    // Если строка не пустая (длина > 1, так как count считает и \0)
    if(count > 1) {
        str -= 2;  // Возвращаем указатель на предпоследний символ
        
        // Если предпоследний символ - перевод строки
        if(*str == '\n') {
            *str = '\0';  // Заменяем его на терминатор
        }
    }
}

int main(void) {
    char str[100];  // Буфер для ввода строки (максимум 99 символов + \0)
    
    // Безопасное чтение строки из стандартного ввода
    // fgets гарантирует, что не будет переполнения буфера
    fgets(str, sizeof(str), stdin);
    
    // Удаляем символ перевода строки (\n), если он есть
    strip_string(str, sizeof(str));
    
    /* Удаляем все символы 'e' из строки
     * Используем технику "двух указателей":
     *   read - позиция чтения (текущий символ)
     *   write - позиция записи (новое положение символа)
     */
    int write = 0;  // Индекс для записи
    for (int read = 0; str[read] != '\0'; ++read) {
        // Если текущий символ не 'e' - копируем его
        if (str[read] != 'e') {
            str[write++] = str[read];
        }
        // Если символ 'e' - пропускаем (не увеличиваем write)
    }
    str[write] = '\0';  // Завершаем строку новым терминатором
    
    // Выводим результат
    printf("%s\n", str);

    return 0;
}