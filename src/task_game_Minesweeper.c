#include <stdio.h>
#include <stdlib.h>

#define SIZE    10
#define MINES   12

int main(void)
{
    char pg[SIZE][SIZE] = {0}; // Игровое поле (инициализировано нулями)
    int mines_placed = 0; // Счётчик установленных мин

    // Инициализация генератора случайных чисел
    srand(12345); // фиксированное значение для тестирования

    while (mines_placed < MINES) {
        int x = rand() % SIZE; // Случайная координата x (0..9)
        int y = rand() % SIZE; // Случайная координата y (0..9)

        // Проверяем, можно ли поставить мину в (x, y)
        if (pg[x][y] == '*') // Если здесь уже есть мина
            continue; // Пропускаем эту итерацию

        int can_place = 1; // Флаг возможности установки мины

        // Проверяем все 8 соседних клеток
        for (int dx = -1; dx <= 1 && can_place; ++dx) {
            for (int dy = -1; dy <= 1 && can_place; ++dy) {
                int nx = x + dx; // Координата соседней клетки по x
                int ny = y + dy; // Координата соседней клетки по y
            
                // Проверка выхода за границы поля
                if (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE) {
                    if (pg[nx][ny] == '*') // Если соседняя клетка содержит мину
                        can_place = 0; // Нельзя ставить мину здесь
                }
            }
        }
                /*Особенности работы цикла проверки(см. выше):
Порядок проверки: от верхнего-левого (-1,-1) до нижнего-правого (1,1) соседа
Текущая клетка: проверяется при (0,0), но всегда пуста на этом этапе
Оптимизация: при can_place = 0 все циклы немедленно прерываются*/

        if (can_place) {
            pg[x][y] = '*'; // Ставим мину
            ++mines_placed; // Увеличиваем счётчик мин
        }
    }

    __assert_verify_pg(pg); // для тестирования (не убирать и должна идти непосредственно перед return 0)
    return 0;
}